<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>坐姿监督监控-晓林技术支持</title>
  <link rel="stylesheet" href="./assets/styles.css" />
</head>
<body>
  <div class="call-root">
    <div class="call-video">
      <video id="video" playsinline muted></video>
      <canvas id="canvas"></canvas>
      <div id="focusRing" class="focus-ring" style="display:none"></div>
    </div>

    <div class="call-top">
      <div class="call-title">
        <strong id="titleText">儿童坐姿</strong>
        <span class="call-chip" id="scorePill" style="display:none">
          <span style="color:var(--muted)">问题</span>
          <span id="issueText">-</span>
        </span>
      </div>

      <div style="display:flex;gap:10px;align-items:center">
        <span class="call-chip" id="zoomPill" title="缩放倍率">
          <span style="color:var(--muted)">倍率</span>
          <span id="zoomText">1.0x</span>
        </span>
        <span class="call-chip">
          <span style="color:var(--muted)">倒计时</span>
          <span id="timerText">00:00</span>
          <span style="color:var(--muted)" id="phaseText">学习</span>
        </span>
        <span class="call-chip">
          <span class="dot" id="statusDot"></span>
          <span id="statusText">等待启动</span>
        </span>
      </div>
    </div>

    <div class="call-side">
      <a class="fab" href="./settings.html" target="_blank" rel="noopener" title="设置（新窗口打开，监控不中断）" style="text-decoration:none" aria-label="设置">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <path d="M12 15.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7Z"/>
          <path d="M19.4 15a7.8 7.8 0 0 0 .1-2l2-1.2-2-3.5-2.3.7a7.6 7.6 0 0 0-1.7-1l-.3-2.4H9l-.3 2.4c-.6.2-1.2.6-1.7 1l-2.3-.7-2 3.5 2 1.2a7.8 7.8 0 0 0 0 2l-2 1.2 2 3.5 2.3-.7c.5.4 1.1.8 1.7 1l.3 2.4h6l.3-2.4c.6-.2 1.2-.6 1.7-1l2.3.7 2-3.5-2-1.2Z"/>
        </svg>
      </a>
    </div>

    <div class="hint-banner" id="suggestionBox">点击下方“开始”后，会自动检测坐姿并用女声提醒。</div>
    <div class="hint-banner" id="deviceHint" style="display:none"></div>

    <div class="call-bottom">
      <button id="btnFlip" class="fab" title="切换摄像头" disabled aria-label="切换摄像头">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h3l2-2h8l2 2h3a2 2 0 0 1 2 2Z"/>
          <path d="M12 17a4 4 0 1 0 0-8 4 4 0 0 0 0 8Z"/>
        </svg>
      </button>
      <button id="btnStart" class="fab primary" title="开始" aria-label="开始">
        <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M8 5v14l11-7L8 5Z"/></svg>
      </button>
      <button id="btnStop" class="fab danger" title="停止" disabled aria-label="停止">
        <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M7 7h10v10H7Z"/></svg>
      </button>
      <button id="btnSpeak" class="fab" title="测试语音" aria-label="测试语音">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <path d="M11 5 6 9H2v6h4l5 4V5Z"/>
          <path d="M15.5 8.5a5 5 0 0 1 0 7"/>
          <path d="M18 6a8 8 0 0 1 0 12"/>
        </svg>
      </button>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/pose.js"></script>
  <script src="./assets/app.js"></script>
  <script>
    const settings = window.PG.loadSettings();

    const els = {
      video: document.getElementById('video'),
      canvas: document.getElementById('canvas'),
      statusDot: document.getElementById('statusDot'),
      statusText: document.getElementById('statusText'),
      zoomText: document.getElementById('zoomText'),
      timerText: document.getElementById('timerText'),
      phaseText: document.getElementById('phaseText'),
      suggestionBox: document.getElementById('suggestionBox'),
      deviceHint: document.getElementById('deviceHint'),
      btnStart: document.getElementById('btnStart'),
      btnStop: document.getElementById('btnStop'),
      btnFlip: document.getElementById('btnFlip'),
      btnSpeak: document.getElementById('btnSpeak'),
      scorePill: document.getElementById('scorePill'),
      issueText: document.getElementById('issueText')
    };

    let stream = null;
    let facingMode = settings.cameraFacingMode || 'user';

    let videoTrack = null;
    let trackCaps = null;
    let trackSettings = null;
    let zoomMin = 1;
    let zoomMax = 1;
    let zoomStep = 0.1;
    let currentZoom = 1;
    let digitalZoom = 1;

    let gestureActive = false;
    let pinchStartDist = 0;
    let pinchStartZoom = 1;
    let pinchStartDigitalZoom = 1;
    let lastTouchAt = 0;
    let tapMoved = false;

    const warningPool = window.PG.linesToArray(settings.warningLines);
    const maybeSpeak = window.PG.createSpeechThrottle();

    let pose = null;
    let running = false;
    let rafId = 0;
    let badStreak = 0;
    let lastEval = null;
    const WARN_STREAK_THRESHOLD = 3;

    // 计时器（先搭骨架，后面会与坐姿检测联动）
    let phase = 'study';
    let phaseRemainingSec = settings.sessionMinutes * 60;
    let ticker = null;

    const RUNTIME_KEY = 'pg_runtime_state_v1';

    function saveRuntimeState(){
      try{
        localStorage.setItem(RUNTIME_KEY, JSON.stringify({
          phase,
          phaseRemainingSec,
          savedAt: Date.now(),
        }));
      }catch(e){
        // ignore
      }
    }

    function restoreRuntimeState(){
      try{
        const raw = localStorage.getItem(RUNTIME_KEY);
        if(!raw) return;
        const st = JSON.parse(raw);
        if(!st) return;
        const p = (st.phase === 'break' || st.phase === 'study') ? st.phase : null;
        const remain = Number(st.phaseRemainingSec);
        const savedAt = Number(st.savedAt);
        if(!p || !Number.isFinite(remain) || !Number.isFinite(savedAt)) return;

        const elapsed = Math.max(0, Math.floor((Date.now() - savedAt) / 1000));

        // 处理跨阶段（学习/休息）切换
        let curPhase = p;
        let curRemain = Math.max(0, remain);
        let left = elapsed;
        while(left > 0){
          if(left < curRemain){
            curRemain -= left;
            left = 0;
          }else{
            left -= curRemain;
            curPhase = curPhase === 'study' ? 'break' : 'study';
            curRemain = (curPhase === 'study' ? (settings.sessionMinutes || 45) : (settings.breakMinutes || 10)) * 60;
          }
        }
        phase = curPhase;
        phaseRemainingSec = curRemain;
      }catch(e){
        // ignore
      }
    }

    function setStatus(level, text){
      els.statusDot.className = 'dot' + (level ? (' ' + level) : '');
      els.statusText.textContent = text;
    }

    function setSuggestion(text){
      els.suggestionBox.textContent = text;
    }

    function updateZoomUI(){
      // 有硬件 zoom 时，倍率 = 硬件 zoom * 数字缩放兜底
      const hz = (trackCaps && typeof trackCaps.zoom === 'object') ? (Number(currentZoom) || 1) : 1;
      const dz = Number(digitalZoom) || 1;
      const z = Math.max(1, hz * dz);
      els.zoomText.textContent = `${z.toFixed(1)}x`;
    }

    function drawOverlay(results){
      const ctx = els.canvas.getContext('2d');
      const w = els.canvas.width;
      const h = els.canvas.height;
      ctx.save();
      ctx.clearRect(0, 0, w, h);

      // 镜像显示时（前置摄像头），只镜像视频，不镜像画布更直观？
      // 这里保持画布与视频同向：对前置摄像头进行镜像绘制。
      if(facingMode === 'user'){
        ctx.translate(w, 0);
        ctx.scale(-1, 1);
      }

      if(results && results.poseLandmarks){
        try{
          window.drawConnectors(ctx, results.poseLandmarks, window.POSE_CONNECTIONS,
            {color:'rgba(93,214,255,.9)', lineWidth:3});
          window.drawLandmarks(ctx, results.poseLandmarks,
            {color:'rgba(255,255,255,.85)', lineWidth:2, radius:2});
        }catch(e){
          // ignore draw errors
        }
      }
      ctx.restore();
    }

    function ensurePose(){
      if(pose) return pose;
      if(!(window.Pose)) throw new Error('Pose 库加载失败，请检查网络/HTTPS');
      pose = new window.Pose({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/${file}`
      });
      pose.setOptions({
        modelComplexity: 0,
        smoothLandmarks: true,
        enableSegmentation: false,
        smoothSegmentation: false,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
      });
      pose.onResults((results) => {
        drawOverlay(results);
        const evalRes = window.PG.postureEvaluate(results && results.poseLandmarks, settings);
        lastEval = evalRes;

        if(!running) return;

        // 只在学习阶段提醒
        if(phase !== 'study'){
          setStatus('warn', '休息时间');
          return;
        }

        setStatus(evalRes.level || '', evalRes.statusText || '');
        setSuggestion(evalRes.suggestion || '');

        if(evalRes && evalRes.issues && evalRes.issues.length){
          els.scorePill.style.display = '';
          els.issueText.textContent = `${evalRes.issues.join('、')}  ${Math.round((evalRes.score || 0)*100)}%`;
        }else{
          els.scorePill.style.display = 'none';
          els.issueText.textContent = '-';
        }

        if(evalRes.level === 'warn' || evalRes.level === 'danger'){
          badStreak++;
        }else{
          badStreak = 0;
        }

        // 连续多帧不良再提醒，避免抖动
        if(badStreak >= WARN_STREAK_THRESHOLD && (evalRes.level === 'warn' || evalRes.level === 'danger')){
          const baseLine = window.PG.pickRandom(warningPool) || '小朋友，坐直一点哦。';
          const fix = (evalRes.level === 'danger')
            ? '现在就调整：背挺直，肩放松，眼睛离书一拳，不要趴写。'
            : '轻轻调整：背挺直一点，头抬起一点。';
          const fallbackText = `${baseLine}${fix}`;

          const toSpeak = String(evalRes.suggestion || fallbackText);
          if(maybeSpeak(toSpeak, settings, { issues: evalRes.issues, ttsText: toSpeak })){
            badStreak = 0;
          }
        }
      });
      return pose;
    }

    function updateTimerUI(){
      els.timerText.textContent = window.PG.formatMMSS(phaseRemainingSec);
      els.phaseText.textContent = phase === 'study' ? '学习' : '休息';
    }

    function stopTicker(){
      if(ticker){
        clearInterval(ticker);
        ticker = null;
      }
    }

    function startTicker(){
      stopTicker();
      updateTimerUI();
      ticker = setInterval(() => {
        phaseRemainingSec = Math.max(0, phaseRemainingSec - 1);
        updateTimerUI();
        saveRuntimeState();
        if(phaseRemainingSec === 0){
          if(phase === 'study'){
            phase = 'break';
            phaseRemainingSec = (settings.breakMinutes || 10) * 60;
            window.PG.speakBreak(settings);
            setStatus('warn', '休息时间');
            setSuggestion('建议：站起来走一走，看看远处 20 秒，让眼睛放松。');
          }else{
            phase = 'study';
            phaseRemainingSec = (settings.sessionMinutes || 45) * 60;
            window.PG.speak('休息结束，我们继续认真写作业。坐直喔。', settings);
            setStatus('', '继续学习');
            setSuggestion('开始新一轮学习：背挺直、肩放松、眼离书一拳。');
          }
          saveRuntimeState();
        }
      }, 1000);
    }

    async function startCamera(){
      if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
        throw new Error('当前浏览器不支持 getUserMedia');
      }

      const constraints = {
        audio: false,
        video: {
          facingMode: { ideal: facingMode },
          width: { ideal: 1280 },
          height: { ideal: 720 }
        }
      };

      stream = await navigator.mediaDevices.getUserMedia(constraints);
      els.video.srcObject = stream;
      await els.video.play();

      videoTrack = stream.getVideoTracks && stream.getVideoTracks()[0] ? stream.getVideoTracks()[0] : null;
      trackCaps = null;
      trackSettings = null;
      zoomMin = 1;
      zoomMax = 1;
      zoomStep = 0.1;
      currentZoom = 1;
      digitalZoom = 1;
      if(videoTrack && videoTrack.getCapabilities){
        try{ trackCaps = videoTrack.getCapabilities(); }catch(e){ trackCaps = null; }
      }
      if(videoTrack && videoTrack.getSettings){
        try{ trackSettings = videoTrack.getSettings(); }catch(e){ trackSettings = null; }
      }
      if(trackCaps && typeof trackCaps.zoom === 'object'){
        zoomMin = Number(trackCaps.zoom.min ?? 1) || 1;
        zoomMax = Number(trackCaps.zoom.max ?? 1) || 1;
        zoomStep = Number(trackCaps.zoom.step ?? 0.1) || 0.1;
      }
      if(trackSettings && typeof trackSettings.zoom === 'number'){
        currentZoom = Number(trackSettings.zoom) || 1;
      }else{
        currentZoom = zoomMin;
      }
      updateZoomUI();
      applyVideoTransform();
      bindCameraGestures();

      els.btnFlip.disabled = false;
      setStatus('ok', '摄像头已开启（坐姿识别接入中）');
      setSuggestion('已开启摄像头。下一步会进行坐姿识别与语音提醒。');

      // 画布大小同步
      const resize = () => {
        const w = els.video.videoWidth || 1280;
        const h = els.video.videoHeight || 720;
        els.canvas.width = w;
        els.canvas.height = h;
      };
      els.video.addEventListener('loadedmetadata', resize, { once: true });
      resize();

      // 前置摄像头体验更像“镜子”：仅对 video 进行镜像
      applyVideoTransform();
    }

    function stopCamera(){
      unbindCameraGestures();
      if(stream){
        for(const t of stream.getTracks()) t.stop();
      }
      stream = null;
      videoTrack = null;
      trackCaps = null;
      trackSettings = null;
      els.video.srcObject = null;
      els.btnFlip.disabled = true;
      setStatus('', '已停止');
      setSuggestion('已停止监控。');
    }

    function clamp(n, a, b){
      return Math.min(b, Math.max(a, n));
    }

    function roundToStep(v, step){
      if(!step || step <= 0) return v;
      return Math.round(v / step) * step;
    }

    function applyVideoTransform(){
      const mirror = facingMode === 'user' ? -1 : 1;
      const scale = digitalZoom > 1 ? digitalZoom : 1;
      // transform 顺序：镜像 + 数字缩放
      els.video.style.transform = mirror === -1 ? `scaleX(-1) scale(${scale})` : `scale(${scale})`;
      els.video.style.transformOrigin = 'center center';
      updateZoomUI();
    }

    async function applyHardwareZoom(z){
      if(!videoTrack || !videoTrack.applyConstraints) return false;
      if(!(trackCaps && typeof trackCaps.zoom === 'object')) return false;
      const nz = clamp(roundToStep(z, zoomStep), zoomMin, zoomMax);
      try{
        await videoTrack.applyConstraints({ advanced: [{ zoom: nz }] });
        currentZoom = nz;
        updateZoomUI();
        return true;
      }catch(e){
        return false;
      }
    }

    function getTouchDist(t1, t2){
      const dx = t1.clientX - t2.clientX;
      const dy = t1.clientY - t2.clientY;
      return Math.sqrt(dx*dx + dy*dy);
    }

    function showFocusRing(x, y){
      const ring = document.getElementById('focusRing');
      ring.style.left = `${x}px`;
      ring.style.top = `${y}px`;
      ring.style.display = '';
      ring.classList.remove('show');
      // 触发 reflow
      void ring.offsetWidth;
      ring.classList.add('show');
      setTimeout(() => {
        ring.classList.remove('show');
        ring.style.display = 'none';
      }, 650);
    }

    async function tryTapToFocus(clientX, clientY){
      if(!videoTrack || !videoTrack.applyConstraints) return false;
      const wrap = els.video.parentElement;
      const rect = wrap.getBoundingClientRect();
      const x = clientX - rect.left;
      const y = clientY - rect.top;

      showFocusRing(x, y);

      // pointsOfInterest / focusMode 支持情况很碎，尽力而为
      try{
        const adv = [];
        if(trackCaps && trackCaps.focusMode){
          const modes = Array.isArray(trackCaps.focusMode) ? trackCaps.focusMode : [];
          if(modes.includes('continuous')) adv.push({ focusMode: 'continuous' });
          else if(modes.includes('single-shot')) adv.push({ focusMode: 'single-shot' });
        }
        if(trackCaps && trackCaps.pointsOfInterest){
          const nx = clamp(x / rect.width, 0, 1);
          const ny = clamp(y / rect.height, 0, 1);
          adv.push({ pointsOfInterest: [{ x: nx, y: ny }] });
        }
        if(!adv.length) return false;
        await videoTrack.applyConstraints({ advanced: adv });
        return true;
      }catch(e){
        return false;
      }
    }

    function bindCameraGestures(){
      const wrap = els.video.parentElement;
      if(!wrap) return;
      wrap.style.touchAction = 'none';

      // Pointer Events（在部分机型/微信上比 touch 可靠）
      if(window.PointerEvent){
        const pts = new Map();
        let pPinch = false;
        let pStartDist = 0;
        let pStartZoom = 1;
        let pStartDigital = 1;
        let pDownAt = 0;
        let pMoved = false;

        const dist = (a, b) => {
          const dx = a.x - b.x;
          const dy = a.y - b.y;
          return Math.sqrt(dx*dx + dy*dy);
        };

        const onPD = (e) => {
          if(!stream) return;
          try{ wrap.setPointerCapture(e.pointerId); }catch(err){}
          pts.set(e.pointerId, { x: e.clientX, y: e.clientY });
          pDownAt = Date.now();
          pMoved = false;
          if(pts.size === 2){
            const arr = Array.from(pts.values());
            pPinch = true;
            pStartDist = dist(arr[0], arr[1]);
            pStartZoom = currentZoom;
            pStartDigital = digitalZoom;
          }
        };

        const onPM = async (e) => {
          if(!stream) return;
          if(!pts.has(e.pointerId)) return;
          pts.set(e.pointerId, { x: e.clientX, y: e.clientY });
          pMoved = true;
          if(pPinch && pts.size === 2){
            const arr = Array.from(pts.values());
            const d2 = dist(arr[0], arr[1]);
            const ratio = pStartDist > 0 ? (d2 / pStartDist) : 1;
            const target = pStartZoom * ratio;
            const ok = await applyHardwareZoom(target);
            if(!ok){
              digitalZoom = clamp(pStartDigital * ratio, 1, 3);
              applyVideoTransform();
            }
            e.preventDefault();
          }
        };

        const onPU = async (e) => {
          if(!stream) return;
          pts.delete(e.pointerId);
          if(pts.size < 2){
            pPinch = false;
            pStartDist = 0;
          }
          const dt = Date.now() - pDownAt;
          const isTap = dt < 260 && !pMoved;
          if(isTap) await tryTapToFocus(e.clientX, e.clientY);
        };

        wrap._pgPointerDown = onPD;
        wrap._pgPointerMove = onPM;
        wrap._pgPointerUp = onPU;
        wrap.addEventListener('pointerdown', onPD, { passive: false });
        wrap.addEventListener('pointermove', onPM, { passive: false });
        wrap.addEventListener('pointerup', onPU, { passive: false });
        wrap.addEventListener('pointercancel', onPU, { passive: false });
        return;
      }

      const onTouchStart = (e) => {
        if(!running && !stream) return;
        lastTouchAt = Date.now();
        tapMoved = false;
        if(e.touches && e.touches.length === 2){
          gestureActive = true;
          pinchStartDist = getTouchDist(e.touches[0], e.touches[1]);
          pinchStartZoom = currentZoom;
          pinchStartDigitalZoom = digitalZoom;
        }
      };

      const onTouchMove = async (e) => {
        if(!stream) return;
        if(e.touches && e.touches.length === 2 && gestureActive){
          tapMoved = true;
          const d = getTouchDist(e.touches[0], e.touches[1]);
          const ratio = pinchStartDist > 0 ? (d / pinchStartDist) : 1;

          // 映射：捏合比例 -> zoom（尽量温和）
          const target = pinchStartZoom * ratio;
          const ok = await applyHardwareZoom(target);
          if(!ok){
            // 数字缩放兜底（最大到 3 倍）
            digitalZoom = clamp(pinchStartDigitalZoom * ratio, 1, 3);
            applyVideoTransform();
          }
          e.preventDefault();
        }else if(e.touches && e.touches.length === 1){
          // 手指拖动算移动，避免误触点按
          tapMoved = true;
        }
      };

      const onTouchEnd = async (e) => {
        if(!stream) return;
        const dt = Date.now() - lastTouchAt;
        const isTap = dt < 300 && !tapMoved;
        gestureActive = false;
        pinchStartDist = 0;
        if(isTap){
          const t = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0] : null;
          if(t) await tryTapToFocus(t.clientX, t.clientY);
        }
      };

      wrap._pgTouchStart = onTouchStart;
      wrap._pgTouchMove = onTouchMove;
      wrap._pgTouchEnd = onTouchEnd;
      wrap.addEventListener('touchstart', onTouchStart, { passive: false });
      wrap.addEventListener('touchmove', onTouchMove, { passive: false });
      wrap.addEventListener('touchend', onTouchEnd, { passive: false });
      wrap.addEventListener('touchcancel', onTouchEnd, { passive: false });

      const onClick = async (e) => {
        if(!stream) return;
        // 非触屏/桌面也允许点击触发对焦（支持就生效）
        await tryTapToFocus(e.clientX, e.clientY);
      };
      wrap._pgClick = onClick;
      wrap.addEventListener('click', onClick);

      if(trackCaps && typeof trackCaps.zoom === 'object'){
        els.deviceHint.style.display = 'none';
      }
    }

    function unbindCameraGestures(){
      const wrap = els.video && els.video.parentElement ? els.video.parentElement : null;
      if(!wrap) return;
      if(wrap._pgPointerDown) wrap.removeEventListener('pointerdown', wrap._pgPointerDown);
      if(wrap._pgPointerMove) wrap.removeEventListener('pointermove', wrap._pgPointerMove);
      if(wrap._pgPointerUp){
        wrap.removeEventListener('pointerup', wrap._pgPointerUp);
        wrap.removeEventListener('pointercancel', wrap._pgPointerUp);
      }
      wrap._pgPointerDown = null;
      wrap._pgPointerMove = null;
      wrap._pgPointerUp = null;
      if(wrap._pgTouchStart) wrap.removeEventListener('touchstart', wrap._pgTouchStart);
      if(wrap._pgTouchMove) wrap.removeEventListener('touchmove', wrap._pgTouchMove);
      if(wrap._pgTouchEnd){
        wrap.removeEventListener('touchend', wrap._pgTouchEnd);
        wrap.removeEventListener('touchcancel', wrap._pgTouchEnd);
      }
      if(wrap._pgClick) wrap.removeEventListener('click', wrap._pgClick);
      wrap._pgTouchStart = null;
      wrap._pgTouchMove = null;
      wrap._pgTouchEnd = null;
      wrap._pgClick = null;
      wrap.style.touchAction = '';
    }

    async function startPoseLoop(){
      ensurePose();
      running = true;
      badStreak = 0;

      const tick = async () => {
        if(!running) return;
        if(!stream || els.video.readyState < 2){
          rafId = requestAnimationFrame(tick);
          return;
        }
        try{
          await pose.send({ image: els.video });
        }catch(e){
          // ignore inference errors
        }
        rafId = requestAnimationFrame(tick);
      };
      rafId = requestAnimationFrame(tick);
    }

    function stopPoseLoop(){
      running = false;
      if(rafId){
        cancelAnimationFrame(rafId);
        rafId = 0;
      }
      const ctx = els.canvas.getContext('2d');
      ctx.clearRect(0, 0, els.canvas.width, els.canvas.height);
    }

    async function flipCamera(){
      facingMode = facingMode === 'user' ? 'environment' : 'user';
      window.PG.saveSettings({ ...settings, cameraFacingMode: facingMode });
      stopPoseLoop();
      stopCamera();
      await startCamera();
      await startPoseLoop();
    }

    function updateDeviceHint(){
      const isHttps = location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
      els.deviceHint.style.display = isHttps ? 'none' : '';
      els.deviceHint.textContent = isHttps ? '' : '提示：手机上必须使用 HTTPS 网站才能打开摄像头。';
    }

    function isWeChat(){
      return /micromessenger/i.test(navigator.userAgent || '');
    }

    function warmupVoices(){
      if(!('speechSynthesis' in window)) return;
      // 触发 voices 初始化（部分浏览器需用户手势）
      try{
        speechSynthesis.getVoices();
      }catch(e){
        // ignore
      }
    }

    function bindAudioUnlockHints(){
      // 微信环境：WeixinJSBridgeReady 触发后更容易解锁音频
      document.addEventListener('WeixinJSBridgeReady', () => {
        window.PG.unlockAudio();
      }, false);

      // 首次触摸/点击时解锁
      const once = () => {
        window.PG.unlockAudio();
        document.removeEventListener('touchstart', once, true);
        document.removeEventListener('click', once, true);
      };
      document.addEventListener('touchstart', once, true);
      document.addEventListener('click', once, true);
    }

    els.btnStart.addEventListener('click', async () => {
      try{
        updateDeviceHint();
        warmupVoices();

        // 关键：用户手势解锁音频（微信/手机浏览器更稳）
        await window.PG.unlockAudio();

        // TTS 在微信里可能需要延迟触发一次
        if(/micromessenger/i.test(navigator.userAgent || '')){
          setTimeout(() => { window.PG.speak('开始监督坐姿。', settings); }, 350);
        }

        if(isWeChat()){
          setSuggestion('检测到微信内置浏览器：如果稍后语音不播报，请先点一次“播放一句”，再开始学习。');
        }

        els.btnStart.disabled = true;
        await startCamera();
        await startPoseLoop();
        startTicker();
        els.btnStop.disabled = false;

        try{ localStorage.setItem('pg_running', '1'); }catch(e){}
      }catch(e){
        els.btnStart.disabled = false;
        setStatus('danger', '启动失败');
        const msg = e && e.message ? e.message : '无法启动摄像头';
        const httpsHint = (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1')
          ? '（提示：手机上必须使用 HTTPS 网站才能打开摄像头）'
          : '';
        const cdnHint = msg.includes('Pose') ? '（提示：可能是网络拦截 CDN，请换网络或稍后重试）' : '';
        setSuggestion(`${msg}${httpsHint}${cdnHint}`);
      }
    });

    els.btnStop.addEventListener('click', () => {
      stopTicker();
      stopPoseLoop();
      stopCamera();
      els.btnStart.disabled = false;
      els.btnStop.disabled = true;

      try{ localStorage.setItem('pg_running', '0'); }catch(e){}
    });

    els.btnFlip.addEventListener('click', async () => {
      try{
        els.btnFlip.disabled = true;
        await flipCamera();
      }finally{
        els.btnFlip.disabled = false;
      }
    });

    els.btnSpeak.addEventListener('click', () => {
      // 微信里先点一次“测试语音”能更稳定解锁播放
      window.PG.unlockAudio();
      window.PG.speak('小朋友，坐直一点点哦。背要挺直，肩膀放松。', settings);
    });

    updateDeviceHint();
    bindAudioUnlockHints();

    restoreRuntimeState();
    updateTimerUI();
    setStatus('', '未开始');

    // 兜底：如果用户返回本页且之前处于运行状态，尝试自动恢复。
    // 注意：部分手机浏览器仍然可能要求一次用户手势，这里尽力而为。
    try{
      const wasRunning = localStorage.getItem('pg_running') === '1';
      if(wasRunning){
        setTimeout(() => {
          if(!els.btnStart.disabled && !els.btnStop.disabled) return;
          if(!els.btnStart.disabled) els.btnStart.click();
        }, 400);
      }
    }catch(e){}
  </script>
</body>
</html>
