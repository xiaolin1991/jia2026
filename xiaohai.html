<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°å­©åå§¿å°å«å£«</title>
    <!-- å¼•å…¥ Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- å¼•å…¥ Noto Sans Inter å­—ä½“ -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body { font-family: 'Inter', sans-serif; }

        /* è‡ªå®šä¹‰ CSS ç”¨äºè§†é¢‘å’Œç”»å¸ƒçš„å åŠ  */
        #container {
            position: relative;
            width: 100%;
            max-width: 600px; /* é™åˆ¶æœ€å¤§å®½åº¦ä»¥é€‚åº”æ¡Œé¢è§†å›¾ */
            margin: 0 auto;
        }
        #video, #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 1rem;
        }
        #video {
            transform: scaleX(-1); /* é•œåƒæ˜¾ç¤ºï¼Œç”¨æˆ·ä½“éªŒæ›´å¥½ */
        }
        #canvas {
            transform: scaleX(-1); /* ä¿æŒé•œåƒä¸€è‡´ */
        }
    </style>
    <!-- å¼•å…¥ MediaPipe Pose (å§¿åŠ¿æ£€æµ‹) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
</head>
<body class="bg-gray-50 min-h-screen p-4 flex flex-col items-center">

    <div class="w-full max-w-lg mb-6 text-center">
        <h1 class="text-3xl font-bold text-blue-700 mb-2">å´½å´½åå§¿å°å«å£«</h1>
        <p class="text-gray-600 text-sm">è¯·å°†æ‰‹æœºæ”¾ç½®åœ¨ç¨³å®šä½ç½®ï¼Œæ­£å¯¹å­©å­ä¸ŠåŠèº«ã€‚</p>
    </div>

    <!-- è§†é¢‘å’Œç”»å¸ƒå®¹å™¨ -->
    <div id="container" class="w-full max-w-lg shadow-2xl bg-gray-900 rounded-xl overflow-hidden aspect-video">
        <video id="video" playsinline></video>
        <canvas id="canvas"></canvas>
    </div>

    <!-- çŠ¶æ€å’Œæ§åˆ¶åŒºåŸŸ -->
    <div class="w-full max-w-lg mt-6 bg-white p-6 rounded-xl shadow-lg">
        <div id="status-message" class="text-center font-semibold text-lg p-3 rounded-lg transition-all duration-300 bg-green-100 text-green-700">
            ç­‰å¾…æ‘„åƒå¤´å¯åŠ¨...
        </div>

        <div class="mt-4 flex flex-col space-y-3">
            <button id="start-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 rounded-lg shadow-md transition duration-150 active:scale-95">
                å¼€å§‹ç›‘æ§ (ç‚¹å‡»å¯åŠ¨è¯­éŸ³æç¤º)
            </button>
            <div class="text-xs text-gray-500 text-center">
                é¦–æ¬¡ç‚¹å‡»ä¼šæ¿€æ´»è¯­éŸ³åˆæˆåŠŸèƒ½ï¼Œç¡®ä¿æç¤ºæœ‰æ•ˆã€‚
            </div>
            <div id="alert-counter" class="text-sm text-red-500 text-center hidden mt-2">
                ä»Šæ—¥å·²æé†’æ¬¡æ•°: 0
            </div>
        </div>

        <div class="mt-6 border-t pt-4">
            <h3 class="text-md font-bold text-gray-700 mb-2">å§¿åŠ¿æ£€æµ‹æŒ‡æ ‡ (ç®€åŒ–)</h3>
            <ul class="text-sm text-gray-600 space-y-1 list-disc list-inside">
                <li><span class="font-medium">å¤´éƒ¨æ­£ç›´åº¦:</span> æ£€æŸ¥é¼»å°–ä¸è‚©è†€ä¸­ç‚¹çš„å‚ç›´å¯¹é½ã€‚</li>
                <li><span class="font-medium">ä¾§å€¾:</span> æ£€æŸ¥å·¦å³è‚©è†€çš„å‚ç›´é«˜åº¦å·®ã€‚</li>
                <li><span class="font-medium">æŒç»­æ—¶é•¿:</span> é”™è¯¯å§¿åŠ¿æŒç»­è¶…è¿‡ 2 ç§’æ‰ä¼šè§¦å‘æé†’ã€‚</li>
            </ul>
        </div>
    </div>

    <script type="module">
        // Global variables
        const videoElement = document.getElementById('video');
        const canvasElement = document.getElementById('canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const statusMessage = document.getElementById('status-message');
        const startButton = document.getElementById('start-button');
        const alertCounter = document.getElementById('alert-counter');

        let isMonitoring = false;
        let pose;
        let badPostureStartTime = 0;
        const BAD_POSTURE_THRESHOLD = 2000; // 2 seconds
        let alertCount = 0;
        let isSpeaking = false; // Flag to prevent overlapping audio alerts

        // Audio unlock variables
        let audioContext = null;
        let audioUnlocked = false;

        const apiKey = ""; 

        // éšæœºè­¦å‘Šè¯­ï¼ŒåŒ…å«çº æ­£å»ºè®®
        const ALERT_MESSAGES = [
            "æ›¹æ— å¥ˆï¼Œå¿«ç‚¹åç›´ï¼ŒèƒŒè¦é åˆ°æ¤…èƒŒå“¦ï¼",
            "å“å‘€ï¼Œæ— å¥ˆè¶´å¾—å¤ªè¿‘äº†ï¼è¯·æŠ¬å¤´ï¼Œè®©çœ¼ç›ç¦»ä¹¦æœ¬è¿œä¸€ç‚¹ã€‚",
            "å°è„‘è¢‹æ­ªå•¦ï¼Œå¿«æŠŠè‚©è†€æ”¾å¹³ï¼Œä¸è¦ä¾§ç€å†™å­—ã€‚",
            "å§¿åŠ¿ä¸å¯¹ï¼Œæ— å¥ˆè¿™æ ·å®¹æ˜“è¿‘è§†å’Œé©¼èƒŒå“¦ã€‚è¯·è°ƒæ•´åå§¿ã€‚",
            "æ³¨æ„ï¼è¯·æŠŠè…°æŒºç›´ï¼Œæ”¶è…¹ï¼Œä¿æŒåŒè‚©ä¸€æ ·é«˜ã€‚"
        ];

        // --- TTS Utility Functions ---

        /**
         * å°† Base64 å­—ç¬¦ä¸²è§£ç ä¸º ArrayBuffer
         * @param {string} base64 base64 ç¼–ç çš„äºŒè¿›åˆ¶æ•°æ®
         * @returns {ArrayBuffer} 
         */
        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }
        
        /**
         * å°è¯•åœ¨ç”¨æˆ·äº¤äº’åè§£é”æµè§ˆå™¨çš„éŸ³é¢‘æ’­æ”¾åŠŸèƒ½ã€‚
         */
        function unlockAudio() {
            if (audioUnlocked) return;
            
            // å°è¯•åˆ›å»º/æ¢å¤ AudioContext
            if (!audioContext) {
                // ç¡®ä¿æµè§ˆå™¨å…¼å®¹æ€§
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            // æ£€æŸ¥ context çŠ¶æ€ï¼Œå¦‚æœæ˜¯ suspended (æµè§ˆå™¨é»˜è®¤ç­–ç•¥)ï¼Œåˆ™å°è¯• resume
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('AudioContext resumed successfully. éŸ³é¢‘å·²è§£é”ã€‚');
                    audioUnlocked = true;
                }).catch(e => {
                    console.error('Failed to resume AudioContext: æ— æ³•æ¢å¤ AudioContext', e);
                });
            } else {
                audioUnlocked = true;
            }
        }


        // --- TTS API Integration (ä½¿ç”¨ AudioContext æ’­æ”¾ PCM) ---

        async function speakAlert(text) {
            // æ£€æŸ¥æ˜¯å¦åœ¨è¯´è¯ä¸­ï¼Œæ˜¯å¦å·²è§£é”ï¼Œä»¥åŠ AudioContext æ˜¯å¦å­˜åœ¨
            if (isSpeaking || !audioUnlocked || !audioContext) {
                 if (!audioUnlocked) console.log("Audio not unlocked yet. Waiting for user interaction.");
                return;
            }
            isSpeaking = true;
            
            // éšæœºå»¶è¿Ÿ 500ms - 1000msï¼Œè®©ç³»ç»Ÿæ›´è‡ªç„¶
            const randomDelay = Math.random() * 500 + 500; 
            await new Promise(resolve => setTimeout(resolve, randomDelay));

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{
                    parts: [{ text: text }]
                }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            // ä½¿ç”¨ "Puck" è¯­éŸ³ (Upbeat/æ´»æ³¼) ä½œä¸ºå¥³å£°
                            prebuiltVoiceConfig: { voiceName: "Puck" } 
                        },
                        // è®¾ç½®è¯­è¨€ä¸ºä¸­æ–‡
                        languageCode: "zh-CN" 
                    }
                },
                model: "gemini-2.5-flash-preview-tts"
            };

            let success = false;
            let retries = 0;
            const MAX_RETRIES = 3;

            while (!success && retries < MAX_RETRIES) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) throw new Error(`API Error: ${response.statusText}`);

                    const result = await response.json();
                    const part = result?.candidates?.[0]?.content?.parts?.[0];
                    const audioData = part?.inlineData?.data;
                    const mimeType = part?.inlineData?.mimeType;

                    if (audioData && mimeType && mimeType.startsWith("audio/")) {
                        // 1. è·å–é‡‡æ ·ç‡ (é»˜è®¤ä¸º 16000)
                        const rateMatch = mimeType.match(/rate=(\d+)/);
                        const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 16000; 

                        // 2. å°† Base64 è½¬æ¢ä¸ºåŸå§‹ PCM ArrayBuffer
                        const pcmBuffer = base64ToArrayBuffer(audioData);
                        
                        // 3. è½¬æ¢ä¸º 16 ä½æœ‰ç¬¦å·æ•´æ•°æ•°ç»„
                        const pcm16 = new Int16Array(pcmBuffer);
                        
                        // 4. åˆ›å»º AudioBuffer (å•å£°é“, é•¿åº¦, é‡‡æ ·ç‡)
                        const audioBuffer = audioContext.createBuffer(1, pcm16.length, sampleRate);
                        const channelData = audioBuffer.getChannelData(0);
                        
                        // 5. å°† 16 ä½æ•´æ•°æ•°æ®è½¬æ¢ä¸º AudioBuffer éœ€è¦çš„ Float32 [-1.0, 1.0] èŒƒå›´
                        for (let i = 0; i < pcm16.length; i++) {
                            channelData[i] = pcm16[i] / 32768.0; 
                        }

                        // 6. åˆ›å»º BufferSource èŠ‚ç‚¹å¹¶æ’­æ”¾
                        const source = audioContext.createBufferSource();
                        source.buffer = audioBuffer;
                        source.connect(audioContext.destination);

                        source.onended = () => {
                            isSpeaking = false; // æ’­æ”¾ç»“æŸåé‡Šæ”¾é”å®š
                        };
                        source.start(0); // ç«‹å³æ’­æ”¾
                        
                        success = true;
                    } else {
                        throw new Error("TTS API returned invalid audio data structure.");
                    }

                } catch (error) {
                    console.error("TTS è¯­éŸ³åˆæˆå¤±è´¥:", error);
                    retries++;
                    if (retries < MAX_RETRIES) {
                        const delay = Math.pow(2, retries) * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay)); // Exponential backoff
                    }
                }
            }
            // æ— è®ºæˆåŠŸæˆ–å¤±è´¥ï¼Œå¦‚æœæœ€ç»ˆæœªæˆåŠŸï¼Œåˆ™æ¸…é™¤é”å®š
            if (!success) {
                console.warn("æ— æ³•æ’­æ”¾è¯­éŸ³æç¤ºï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–APIçŠ¶æ€ã€‚");
                isSpeaking = false;
            }
        }

        // --- Posture Analysis Logic (Unchanged) ---

        /**
         * æ£€æŸ¥æ£€æµ‹åˆ°çš„å§¿åŠ¿æ˜¯å¦ç¬¦åˆè‰¯å¥½åå§¿çš„æ ‡å‡†ã€‚
         * @param {Object} results MediaPipe Pose ç»“æœ
         * @returns {string | null} é”™è¯¯æè¿°å­—ç¬¦ä¸²ï¼Œå¦‚æœå§¿åŠ¿è‰¯å¥½åˆ™è¿”å› null
         */
        function checkPosture(results) {
            const landmarks = results.poseWorldLandmarks;
            if (!landmarks || landmarks.length === 0) {
                return "æœªæ£€æµ‹åˆ°äººä½“ã€‚";
            }

            // è·å–å…³é”®ç‚¹ (ä½¿ç”¨ä¸–ç•Œåæ ‡ World Landmarks ä»¥å‡å°‘é€è§†å¤±çœŸ)
            const nose = landmarks[POSE_LANDMARKS.NOSE];
            const leftShoulder = landmarks[POSE_LANDMARKS.LEFT_SHOULDER];
            const rightShoulder = landmarks[POSE_LANDMARKS.RIGHT_SHOULDER];
            
            // ä½¿ç”¨å¯è§†åº¦ (visibility) æ£€æŸ¥å…³é”®ç‚¹æ˜¯å¦è¢«é®æŒ¡æˆ–åœ¨è§†çº¿å¤–
            const minVisibility = 0.6;
            if (nose.visibility < minVisibility || leftShoulder.visibility < minVisibility || rightShoulder.visibility < minVisibility) {
                return "å…³é”®ç‚¹ä¸å¯è§ï¼Œè¯·ä¿æŒå®Œæ•´èº«ä½“åœ¨é•œå¤´å†…ã€‚";
            }

            // 1. å¤´éƒ¨ä½å‚/è¶´æ¡Œæ£€æµ‹ (æ£€æŸ¥é¼»å­ç›¸å¯¹äºè‚©è†€çš„å‚ç›´ä½ç½®)
            const shoulderMidY = (leftShoulder.y + rightShoulder.y) / 2;
            const noseY = nose.y;

            const verticalSlouchTolerance = 0.08; // 8% çš„ä¸–ç•Œåæ ‡å·®å€¼
            if (noseY - shoulderMidY > verticalSlouchTolerance) {
                return "å¤´éƒ¨ä½å‚ï¼Œè¯·åç›´ï¼";
            }
            
            // 2. ä¾§å€¾/æ­ªæ–œæ£€æµ‹ (æ£€æŸ¥å·¦å³è‚©è†€çš„å‚ç›´é«˜åº¦å·®)
            const sideLeanTolerance = 0.05; // 5% çš„ä¸–ç•Œåæ ‡å·®å€¼
            const shoulderDiffY = Math.abs(leftShoulder.y - rightShoulder.y);

            if (shoulderDiffY > sideLeanTolerance) {
                return "èº«ä½“æ­ªæ–œï¼Œè¯·ä¿æŒåŒè‚©æ°´å¹³ï¼";
            }

            // å§¿åŠ¿è‰¯å¥½
            return null;
        }


        // --- MediaPipe Callback ---

        function onResults(results) {
            if (!isMonitoring) return;

            // ç»˜åˆ¶æ¸…ç©ºç”»å¸ƒ
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            // ç»˜åˆ¶å§¿åŠ¿å…³é”®ç‚¹å’Œè¿æ¥çº¿
            drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS,
                           {color: '#00FF00', lineWidth: 4});
            drawLandmarks(canvasCtx, results.poseLandmarks,
                          {color: '#FF0000', lineWidth: 2});
            canvasCtx.restore();

            // å§¿åŠ¿æ£€æµ‹é€»è¾‘
            const error = checkPosture(results);

            if (error) {
                // æ£€æµ‹åˆ°é”™è¯¯å§¿åŠ¿
                if (badPostureStartTime === 0) {
                    // è®°å½•é”™è¯¯å§¿åŠ¿å¼€å§‹æ—¶é—´
                    badPostureStartTime = Date.now();
                } else if (Date.now() - badPostureStartTime >= BAD_POSTURE_THRESHOLD) {
                    // é”™è¯¯å§¿åŠ¿æŒç»­æ—¶é—´è¶…è¿‡é˜ˆå€¼ï¼Œå‘å‡ºè­¦å‘Š
                    const warningMessage = ALERT_MESSAGES[Math.floor(Math.random() * ALERT_MESSAGES.length)];
                    
                    statusMessage.textContent = "ğŸš¨ " + warningMessage;
                    statusMessage.className = 'text-center font-semibold text-lg p-3 rounded-lg bg-red-500 text-white shadow-xl animate-pulse';

                    // æ’­æ”¾è¯­éŸ³è­¦å‘Š
                    if (!isSpeaking) {
                        speakAlert(warningMessage);
                        alertCount++;
                        alertCounter.textContent = `ä»Šæ—¥å·²æé†’æ¬¡æ•°: ${alertCount}`;
                        alertCounter.classList.remove('hidden');
                    }
                    
                    // é‡ç½®è®¡æ—¶å™¨ï¼Œé¿å…è¿ç»­è§¦å‘ï¼Œç›´åˆ°å§¿åŠ¿çº æ­£
                    badPostureStartTime = Date.now(); 
                } else {
                    // ä»åœ¨é”™è¯¯å§¿åŠ¿è®¡æ—¶ä¸­
                    const remaining = ((BAD_POSTURE_THRESHOLD - (Date.now() - badPostureStartTime)) / 1000).toFixed(1);
                    statusMessage.textContent = `âš ï¸ æ­£åœ¨æ£€æµ‹é”™è¯¯åå§¿...è¯·åœ¨ ${remaining} ç§’å†…çº æ­£ã€‚`;
                    statusMessage.className = 'text-center font-semibold text-lg p-3 rounded-lg bg-yellow-200 text-yellow-800';
                }

            } else {
                // å§¿åŠ¿è‰¯å¥½
                badPostureStartTime = 0; // é‡ç½®è®¡æ—¶å™¨
                statusMessage.textContent = 'âœ… åå§¿ç«¯æ­£ï¼Œç»§ç»­ä¿æŒï¼';
                statusMessage.className = 'text-center font-semibold text-lg p-3 rounded-lg bg-green-100 text-green-700';
            }
        }


        // --- Initialization and Camera Setup (Unchanged) ---

        function onVideoLoaded() {
             // ç¡®ä¿ç”»å¸ƒå’Œè§†é¢‘å°ºå¯¸ä¸€è‡´
            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;
            // ç¡®ä¿å®¹å™¨ä¿æŒæ­£ç¡®çš„å®½é«˜æ¯”
            const aspectRatio = videoElement.videoHeight / videoElement.videoWidth;
            document.getElementById('container').style.paddingBottom = `${aspectRatio * 100}%`;
        }


        function startCamera() {
            // è¯·æ±‚å‰ç½®æ‘„åƒå¤´æƒé™
            navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } })
                .then(stream => {
                    videoElement.srcObject = stream;
                    videoElement.onloadedmetadata = () => {
                        videoElement.play();
                        onVideoLoaded(); // è°ƒæ•´ç”»å¸ƒå¤§å°
                        setupPose(); // å¯åŠ¨ MediaPipe
                    };
                    statusMessage.textContent = 'æ‘„åƒå¤´å·²å¯åŠ¨ã€‚';
                })
                .catch(err => {
                    console.error("æ— æ³•è®¿é—®æ‘„åƒå¤´: ", err);
                    statusMessage.textContent = 'âŒ æ— æ³•è®¿é—®æ‘„åƒå¤´ã€‚è¯·æ£€æŸ¥æƒé™æˆ–è®¾å¤‡ã€‚';
                });
        }
        
        function setupPose() {
            pose = new Pose({locateFile: (file) => {
                // MediaPipe æ¨¡å‹æ–‡ä»¶è·¯å¾„
                return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
            }});
            
            // é…ç½®å§¿åŠ¿æ£€æµ‹
            pose.setOptions({
                modelComplexity: 1, // é€‚ä¸­å¤æ‚åº¦ï¼Œé€‚åˆç§»åŠ¨ç«¯
                smoothLandmarks: true,
                enableSegmentation: false,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            pose.onResults(onResults);

            // å¯åŠ¨ CameraHelper æ¥å¾ªç¯å‘é€è§†é¢‘å¸§ç»™ MediaPipe
            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    if (isMonitoring) {
                        await pose.send({image: videoElement});
                    }
                },
                width: 640,
                height: 480
            });
            camera.start();
        }

        // --- Event Listener ---
        startButton.addEventListener('click', async () => {
            if (!isMonitoring) {
                // IMPORTANT: Call unlockAudio on user interaction to bypass browser autoplay restrictions
                unlockAudio(); 

                isMonitoring = true;
                startButton.textContent = 'ç›‘æ§å·²æ¿€æ´» (ç‚¹å‡»é™éŸ³)';
                startButton.classList.remove('bg-blue-600');
                startButton.classList.add('bg-gray-400');
                statusMessage.textContent = 'ç›‘æ§å·²æ¿€æ´»ï¼Œè¯·ä¿æŒè‰¯å¥½åå§¿ã€‚';
                statusMessage.className = 'text-center font-semibold text-lg p-3 rounded-lg bg-green-100 text-green-700';
            } else {
                isMonitoring = false;
                badPostureStartTime = 0;
                startButton.textContent = 'å¼€å§‹ç›‘æ§ (ç‚¹å‡»å¯åŠ¨è¯­éŸ³æç¤º)';
                startButton.classList.remove('bg-gray-400');
                startButton.classList.add('bg-blue-600');
                statusMessage.textContent = 'ç›‘æ§æš‚åœï¼Œè¯·ç‚¹å‡»é‡æ–°æ¿€æ´»ã€‚';
                statusMessage.className = 'text-center font-semibold text-lg p-3 rounded-lg bg-gray-200 text-gray-700';
            }
        });

        // å¯åŠ¨æµç¨‹
        window.onload = startCamera;
        
        // è°ƒè¯•ç”¨ï¼šè®¾ç½® Firebase æ—¥å¿—çº§åˆ«ï¼ˆå³ä½¿æ²¡æœ‰ç”¨åˆ° Firebase ä¹Ÿè¦ä¿ç•™æ­¤è¡Œï¼‰
        if (typeof setLogLevel !== 'undefined') {
            setLogLevel('Debug');
        }
    </script>
</body>
</html>
